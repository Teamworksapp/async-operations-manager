{"version":3,"sources":["../src/asyncOperationStateUtils.js"],"names":["updateAsyncOperationDescriptor","state","descriptorOptions","asyncOperationDescriptor","debug","parentOperationDescriptorId","invalidatingOperationsDescriptorIds","alwaysImmutable","minCacheTime","maxCacheTime","requiredParams","PropTypes","checkPropTypes","asyncOperationDescriptorPropType","descriptors","descriptorId","getAsyncOperation","asyncOperationStep","asyncOperationKey","asyncOperationParams","fieldsToAdd","operations","parentAsyncOperation","asyncOperation","config","asyncOperationManagerConfig","getConfig","fieldsToAddToAction","logger","verboseLoggingCallback","infoLoggingCallback","parentAsyncOperationDescriptor","parentAsyncOperationKey","operationType","ASYNC_OPERATION_TYPES","READ","ASYNC_OPERATION_STEPS","RESOLVE_ASYNC_OPERATION","invalidateOperation","invalidatingAsyncOperationDescriptor","invalidatingAsyncOperationKey","invalidatingOperation","lastDataStatusTime","valueOf","lastFetchStatusTime","readAsyncOperationFieldsToPullFromParent","updateAsyncOperation","asyncOperationPropType","bulkUpdateAsyncOperations","asyncOperationsList","accumulator"],"mappings":"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","sourcesContent":["\n// TODO: JSDocify every function\nimport { pick, forEach, reduce } from 'lodash';\nimport PropTypes from 'prop-types';\n\nimport asyncOperationManagerConfig from './config';\n\nimport {\n  ASYNC_OPERATION_TYPES,\n  ASYNC_OPERATION_STEPS,\n  readAsyncOperationFieldsToPullFromParent,\n} from './constants';\n\nimport {\n  getAsyncOperationInfo,\n} from './helpers';\n\nimport {\n  asyncOperationDescriptorPropType,\n  asyncOperationPropType,\n} from './types';\n\nimport {\n  initialReadAsyncOperationForAction,\n  initialWriteAsyncOperationForAction,\n} from './asyncOperationUtils';\n\n// // //\n// // // These are all pure functions that return new or existing state or\n// // // pieces of new or existing state from their inputs.\n// // //\n\nconst updateAsyncOperationDescriptor = (state, descriptorOptions) => {\n  const asyncOperationDescriptor = {\n    debug: false,\n    parentOperationDescriptorId: null,\n    invalidatingOperationsDescriptorIds: null,\n    alwaysImmutable: false,\n    minCacheTime: 5000,\n    maxCacheTime: 60000,\n    requiredParams: {},\n    ...descriptorOptions,\n  };\n\n  PropTypes.checkPropTypes(asyncOperationDescriptorPropType, asyncOperationDescriptor, 'prop', 'asyncOperationDescriptor');\n  \n  return {\n    ...state,\n    descriptors: {\n      ...state.descriptors,\n      [asyncOperationDescriptor.descriptorId]: asyncOperationDescriptor,\n    },\n  };\n};\n\n// This function will do all the work to determine if an async operation is returned as an initial async operation\n// (if it is not found in state), an asyncOperation with parentAsyncOperation metaData (recursively searched to find if the parentAsyncOperation is more\n// up-to-date) or just the asyncOperation itself if the none of the above apply.\nconst getAsyncOperation = ({\n  state,\n  asyncOperationStep,\n  asyncOperationKey,\n  asyncOperationDescriptor,\n  asyncOperationParams,\n  fieldsToAdd,\n}) => {\n  const { operations, descriptors } = state;\n\n  let parentAsyncOperation;\n  const asyncOperation = operations[asyncOperationKey] || null;\n\n  const config = asyncOperationManagerConfig.getConfig();\n  const fieldsToAddToAction = {\n    ...asyncOperationParams,\n    ...fieldsToAdd,\n    // key for the descriptor of the asyncOperation\n    descriptorId: asyncOperationDescriptor.descriptorId,\n  };\n\n  if (asyncOperationDescriptor.debug) {\n    config.logger.verboseLoggingCallback(`Inside getAsyncOperation for ${asyncOperationKey}`);\n    config.logger.infoLoggingCallback('getAsyncOperation [Data Snapshot]:', {\n      state,\n      asyncOperationParams,\n      asyncOperationDescriptor,\n      asyncOperation,\n      asyncOperationKey,\n    });\n  }\n\n  if (asyncOperationDescriptor.parentOperationDescriptorId) {\n    // grab key, descriptor, params, and async operation for parentAsyncOperation\n    const {\n      asyncOperationDescriptor: parentAsyncOperationDescriptor,\n      asyncOperationKey: parentAsyncOperationKey,\n    } = getAsyncOperationInfo(descriptors, asyncOperationDescriptor.parentOperationDescriptorId, asyncOperationParams);\n\n    if (parentAsyncOperationDescriptor.operationType === ASYNC_OPERATION_TYPES.READ) {\n      parentAsyncOperation = getAsyncOperation({\n        state,\n        asyncOperationStep,\n        asyncOperationKey: parentAsyncOperationKey,\n        asyncOperationDescriptor: parentAsyncOperationDescriptor,\n        asyncOperationParams,\n        fieldsToAdd: fieldsToAddToAction,\n      });\n    }\n  }\n\n  if (!asyncOperation) {\n    if (asyncOperationDescriptor.debug) {\n      config.logger.verboseLoggingCallback(`asyncOperation not found with given key: ${asyncOperationKey}. Defaulting to an initial asyncOperation`);\n    }\n    return asyncOperationDescriptor.operationType === ASYNC_OPERATION_TYPES.READ\n      ? initialReadAsyncOperationForAction(asyncOperationDescriptor.descriptorId, asyncOperationKey, fieldsToAddToAction, parentAsyncOperation)\n      : initialWriteAsyncOperationForAction(asyncOperationDescriptor.descriptorId, asyncOperationKey, fieldsToAddToAction, parentAsyncOperation);\n  }\n\n  if (asyncOperationDescriptor.invalidatingOperationsDescriptorIds && asyncOperationStep === ASYNC_OPERATION_STEPS.RESOLVE_ASYNC_OPERATION) {\n    // we want to detect whether to invalidate the async operation if an async operation has been found\n    let invalidateOperation = false;\n\n    forEach(asyncOperationDescriptor.invalidatingOperationsDescriptorIds, (descriptorId) => {\n      // hanlde if an asyncOperation invalidates itself\n      if (descriptorId === asyncOperationDescriptor.descriptorId) {\n        invalidateOperation = true;\n        return false;\n      }\n\n      const {\n        asyncOperationDescriptor: invalidatingAsyncOperationDescriptor,\n        asyncOperationKey: invalidatingAsyncOperationKey,\n      } = getAsyncOperationInfo(descriptors, descriptorId, asyncOperationParams);\n      const invalidatingOperation = getAsyncOperation({\n        state,\n        asyncOperationStep,\n        invalidatingAsyncOperationKey,\n        asyncOperationDescriptor: invalidatingAsyncOperationDescriptor,\n        asyncOperationParams,\n        fieldsToAdd: fieldsToAddToAction,\n      });\n\n      // Handle invalidating operations with write or read operations.\n      invalidateOperation = invalidatingAsyncOperationDescriptor.operationType === ASYNC_OPERATION_TYPES.READ ?\n        invalidatingOperation.lastDataStatusTime.valueOf() >= asyncOperation.lastDataStatusTime.valueOf() :\n        invalidatingOperation.lastFetchStatusTime.valueOf() >= asyncOperation.lastFetchStatusTime.valueOf();\n\n      if (invalidateOperation) {\n        return false;\n      }\n      return true;\n    });\n\n    if (invalidateOperation) {\n      return initialReadAsyncOperationForAction(asyncOperationDescriptor.descriptorId, asyncOperationKey, fieldsToAddToAction);\n    }\n  }\n\n  // We want to determine whether or not to use that parentAsyncOperation metaData based on the\n  // newness of it's data in comparison to the asyncOperation\n  if (parentAsyncOperation) {\n    return parentAsyncOperation.lastDataStatusTime.valueOf() >= asyncOperation.lastDataStatusTime.valueOf()\n      ? {\n        ...asyncOperation,\n        // use parent async operation metaData (lastDataStatusTime, lastFetchStatusTime. etc...)\n        ...pick(parentAsyncOperation, readAsyncOperationFieldsToPullFromParent),\n      }\n      : asyncOperation;\n  }\n\n  return asyncOperation;\n};\n\nconst updateAsyncOperation = (state, asyncOperationKey, asyncOperation, asyncOperationDescriptor) => {\n  const config = asyncOperationManagerConfig.getConfig();\n  if (asyncOperationDescriptor.debug) {\n    config.logger.verboseLoggingCallback(`Inside updateAsyncOperation for ${asyncOperationKey}`);\n    config.logger.infoLoggingCallback('updateAsyncOperation [Data Snapshot]:', {\n      asyncOperationDescriptor,\n      asyncOperation,\n      asyncOperationKey,\n    });\n  }\n\n  PropTypes.checkPropTypes(asyncOperationPropType, asyncOperation, 'prop', 'asyncOperation');\n\n  return {\n    operations: {\n      ...state.operations,\n      [asyncOperationKey]: asyncOperation,\n    },\n  };\n};\n\nconst bulkUpdateAsyncOperations = (state, asyncOperationsList) => {\n  return reduce(asyncOperationsList, (accumulator, { asyncOperationKey, asyncOperation, asyncOperationDescriptor }) => {\n    return updateAsyncOperation(accumulator, asyncOperationKey, asyncOperation, asyncOperationDescriptor);\n  }, state);\n};\n\nexport default {\n  updateAsyncOperationDescriptor,\n\n  updateAsyncOperation,\n  bulkUpdateAsyncOperations,\n\n  getAsyncOperation,\n};\n"],"file":"asyncOperationStateUtils.js"}