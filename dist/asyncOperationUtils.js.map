{"version":3,"sources":["../src/asyncOperationUtils.js"],"names":["alwaysImmutable","initialReadAsyncOperation","fetchStatus","FETCH_STATUS","NULL","dataStatus","DATA_STATUS","ABSENT","message","lastFetchStatusTime","lastFetchFailed","lastDataStatusTime","initialWriteAsyncOperation","initialReadAsyncOperationForAction","descriptorId","params","key","fieldsToAdd","parentAsyncOperation","readAsyncOperationFieldsToPullFromParent","initialWriteAsyncOperationForAction","beginReadAsyncOperation","previousAsyncOperation","fieldsForNewAsyncOperation","PENDING","Date","now","PRESENT","Object","assign","beginWriteAsyncOperation","initialAsyncOperation","resolveReadAsyncOperation","currentTime","fieldsToUpdate","SUCCESSFUL","resolveWriteAsyncOperation","rejectReadAsyncOperation","FAILED","rejectWriteAsyncOperation"],"mappings":"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","sourcesContent":["// @flow\n// TODO: JSDocify every function\n\nimport { pick } from 'lodash';\n\nimport {\n  readAsyncOperationFieldsToPullFromParent,\n  FETCH_STATUS,\n  DATA_STATUS,\n} from './constants';\n\n// An asyncOperation is an object that tracks the status of some data that we fetch from\n// somewhere or send to somewhere. Each asyncOperation represents\n// a single 'dataset' (which, today, always means a single ajax request -- although that's\n// not a fixed constraint), and they're stored in Redux under operation-specific keys.\n//\n// \"read\" and \"write\" operations are *slightly* different, but they work the same way.\n//\n// The asyncOperation tracks information about:\n//  - Our last attempt to fetch or write the data\n//  - Whether we have data from a prior successful attempt (for reads only)\n//  - The action and params and such that were used to request the data\n//\n// This file includes standalone functions that transform asyncOperations when we\n// begin, resolve, or reject requests. In general, only reducers should use these functions.\n\n\n/**\n * asyncOperations were originally always treated as proper immutable objects, but for background refreshes\n * it doesn't make sense to create a new object unless the status is actually different somehow, because\n * the new object will cause any screens that select the asyncOperation to rerender.\n *\n * So this is an experiment in having the asyncOperation object be *semi*-immutable: it will only yield\n * a new object instance if there's a noteworthy change in status.\n *\n * @type {boolean}\n */\nconst alwaysImmutable = false;\n\n\n/**\n * This is the default look of brand new, never-touched asyncOperation.\n */\nconst initialReadAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: FETCH_STATUS.NULL,\n  dataStatus: DATA_STATUS.ABSENT,\n  message: null,\n  lastFetchStatusTime: 0,\n  lastFetchFailed: false,\n  lastDataStatusTime: 0,\n};\n\n\nconst initialWriteAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: FETCH_STATUS.NULL,\n  message: null,\n  lastFetchStatusTime: 0,\n};\n\n// Note that we'll pull in any status (dataStatus, fetchStatus, etc) from the parent\n// operation (which *should* be fetchAllBeveragesForOrg) to seed the initial status.\nconst initialReadAsyncOperationForAction = (\n  descriptorId,\n  params,\n  key,\n  fieldsToAdd = {},\n  parentAsyncOperation = null,\n) => ({\n  ...initialReadAsyncOperation,\n  ...(parentAsyncOperation ? pick(parentAsyncOperation, readAsyncOperationFieldsToPullFromParent) : {}),\n  ...fieldsToAdd,\n  descriptorId,\n  params,\n  key,\n});\n\nconst initialWriteAsyncOperationForAction = (\n  descriptorId,\n  params,\n  key,\n  fieldsToAdd = {},\n) => ({\n  ...initialWriteAsyncOperation,\n  ...fieldsToAdd,\n  descriptorId,\n  params,\n  key,\n});\n\n/**\n * These are intended for use in reducers, when a __BEGIN action comes in:\n * For read operations, we'll retain any prior dataStatus, but everything else gets reset.\n * Write operations are always a new, blank backendAsyncOperation.\n *\n * Note that you'll always want to specify `descriptorId` in fieldsToAdd, along with any IDs.\n */\nconst beginReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const fieldsForNewAsyncOperation = {\n    // We re-initialize the entire operation state (except descriptorId and dataStatus) on __BEGIN.\n    // (resolve/reject *don't* re-initialize: they carry through any IDs or other fields from before)\n    descriptorId: previousAsyncOperation.descriptorId,\n    fetchStatus: FETCH_STATUS.PENDING,\n    dataStatus: previousAsyncOperation.dataStatus,\n    message: null,\n    lastFetchStatusTime: Date.now(),\n    lastDataStatusTime: previousAsyncOperation.lastDataStatusTime,\n    ...fieldsToAdd,\n  };\n  if (alwaysImmutable || previousAsyncOperation.dataStatus !== DATA_STATUS.PRESENT) {\n    return fieldsForNewAsyncOperation;\n  }\n  Object.assign(previousAsyncOperation, fieldsForNewAsyncOperation);\n  return previousAsyncOperation;\n};\n// Note that the 'write' works the same way as 'read', but instead of calling the base\n// operation \"previousAsyncOperation\" we call it \"initialAsyncOperation\" since its role is different.\nconst beginWriteAsyncOperation = (\n  initialAsyncOperation = initialWriteAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  ...initialWriteAsyncOperation,\n  descriptorId: initialAsyncOperation.descriptorId,\n  fetchStatus: FETCH_STATUS.PENDING,\n  message: null,\n  lastFetchStatusTime: Date.now(),\n  ...fieldsToAdd,\n});\n\n/**\n * These are intended for use in reducers, when a __RESOLVE action comes in:\n * we'll mark that we have data, and will overwrite any prior data status.\n */\nconst resolveReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const currentTime = Date.now();\n  const fieldsToUpdate = {\n    fetchStatus: FETCH_STATUS.SUCCESSFUL,\n    dataStatus: DATA_STATUS.PRESENT,\n    lastFetchStatusTime: currentTime,\n    lastFetchFailed: false,\n    lastDataStatusTime: currentTime,\n    ...fieldsToAdd,\n  };\n  if (alwaysImmutable || previousAsyncOperation.lastFetchFailed || previousAsyncOperation.dataStatus !== DATA_STATUS.PRESENT) {\n    return {\n      ...previousAsyncOperation,\n      ...fieldsToUpdate,\n    };\n  }\n  // Else: we already had data, and we weren't asked to be immutable, so this isn't a noteworthy change,\n  // so mutate in place. (Eep)\n  Object.assign(previousAsyncOperation, fieldsToUpdate);\n  return previousAsyncOperation;\n};\n\nconst resolveWriteAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => {\n  const currentTime = Date.now();\n  return {\n    ...previousAsyncOperation,\n    fetchStatus: FETCH_STATUS.SUCCESSFUL,\n    lastFetchStatusTime: currentTime,\n    ...fieldsToAdd,\n  };\n};\n\n/**\n * These are intended for use in reducers, when a __REJECT action comes in:\n * we'll mark that things failed, but won't alter any prior data status (if it's a read).\n *\n * Note that you'll almost always want to specify `message` in fieldsToAdd.\n */\nconst rejectReadAsyncOperation = (\n  previousAsyncOperation = initialReadAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  ...previousAsyncOperation,\n  fetchStatus: FETCH_STATUS.FAILED,\n  lastFetchStatusTime: Date.now(),\n  lastFetchFailed: true,\n  ...fieldsToAdd,\n});\n\nconst rejectWriteAsyncOperation = (\n  previousAsyncOperation,\n  fieldsToAdd = {},\n) => ({\n  ...previousAsyncOperation,\n  fetchStatus: FETCH_STATUS.FAILED,\n  lastFetchStatusTime: Date.now(),\n  ...fieldsToAdd,\n});\n\n\nexport {\n  initialReadAsyncOperationForAction,\n  initialWriteAsyncOperationForAction,\n  beginReadAsyncOperation,\n  beginWriteAsyncOperation,\n  resolveReadAsyncOperation,\n  resolveWriteAsyncOperation,\n  rejectReadAsyncOperation,\n  rejectWriteAsyncOperation,\n};\n"],"file":"asyncOperationUtils.js"}