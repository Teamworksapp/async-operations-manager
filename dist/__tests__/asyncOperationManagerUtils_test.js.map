{"version":3,"sources":["../../src/__tests__/asyncOperationManagerUtils_test.js"],"names":["initialState","operations","describe","state","beforeEach","asyncOperationManagerState","clearState","it","descriptorId","requiredParams","operationType","registeredAsyncDescriptors","descriptors","Object","keys","to","have","lengthOf","all","parentAsyncOperation","debug","alwaysImmutable","minCacheTime","maxCacheTime","asyncOperationDescriptor","FETCH_PERSON_DATA_BY_ID","be","an","matchSnapshot","dateNowStub","jest","fn","global","Date","now","newOperationsState","ASYNC_OPERATION_STEPS","BEGIN_ASYNC_OPERATION","personId","nested","include","FETCH_PERSON_DATA_111","fetchStatus","dataStatus","message","lastFetchStatusTime","lastDataStatusTime","RESOLVE_ASYNC_OPERATION","REJECT_ASYNC_OPERATION","UPDATE_PERSON_DATA_111"],"mappings":"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","sourcesContent":["/* eslint-env jest */\nimport { expect } from 'chai';\n\nimport {\n  getAsyncOperationsManagerState,\n  registerAsyncOperationDescriptors,\n  getStateForOperationAfterStep,\n} from '../asyncOperationManagerUtils';\n\nimport { ASYNC_OPERATION_STEPS } from '../constants';\n\nimport {\n  asyncOperationManagerState,\n} from '../asyncOperationManagerState';\n\nconst initialState = {\n  operations: {},\n};\n\ndescribe('asyncOperationManagerUtils', () => {\n  let state;\n  beforeEach(() => {\n    asyncOperationManagerState.clearState();\n    state = initialState;\n  });\n  describe('registerAsyncOperationDescriptors', () => {\n    it('should accept object argument to register one async operation decriptor to state', () => {\n      registerAsyncOperationDescriptors(\n        {\n          descriptorId: 'FETCH_ALL_BEVERAGES_FOR_ORG',\n          requiredParams: ['orgId'],\n          operationType: 'READ',\n        },\n      );\n\n      const { descriptors: registeredAsyncDescriptors } = getAsyncOperationsManagerState(state);\n      expect(Object.keys(registeredAsyncDescriptors)).to.have.lengthOf(1);\n      expect(registeredAsyncDescriptors).to.have.all.keys('FETCH_ALL_BEVERAGES_FOR_ORG');\n    });\n\n    it('should accept array argument to register multiple async operation descriptors to state', () => {\n      registerAsyncOperationDescriptors([\n        {\n          descriptorId: 'FETCH_ALL_BEVERAGES_FOR_ORG',\n          requiredParams: ['orgId'],\n          operationType: 'READ',\n        },\n        {\n          descriptorId: 'DRINK_BEVERAGE_BY_ID_FOR_ORG',\n          requiredParams: ['orgId', 'beverageId'],\n          operationType: 'WRITE',\n        },\n      ]);\n\n      const { descriptors: registeredAsyncDescriptors } = getAsyncOperationsManagerState(state);\n      expect(Object.keys(registeredAsyncDescriptors)).to.have.lengthOf(2);\n      expect(registeredAsyncDescriptors).to.have.all.keys('FETCH_ALL_BEVERAGES_FOR_ORG', 'DRINK_BEVERAGE_BY_ID_FOR_ORG');\n    });\n  });\n\n  describe('getAsyncOperationDescriptor', () => {\n    it('should successfully return a registered asyncOperationDescriptor', () => {\n      registerAsyncOperationDescriptors({\n        descriptorId: 'FETCH_PERSON_DATA_BY_ID',\n        requiredParams: ['personId'],\n        operationType: 'READ',\n        // optional values\n        parentAsyncOperation: 'FETCH_ALL_PERSON_DATA',\n        debug: false,\n        alwaysImmutable: false,\n        minCacheTime: 5000,\n        maxCacheTime: 60000,\n      });\n\n      const { descriptors: registeredAsyncDescriptors } = getAsyncOperationsManagerState(state);\n      const asyncOperationDescriptor = registeredAsyncDescriptors.FETCH_PERSON_DATA_BY_ID;\n      expect(asyncOperationDescriptor).to.be.an('object');\n      expect(asyncOperationDescriptor).to.matchSnapshot('well formed async operation descriptor');\n    });\n  });\n\n  describe('getStateForOperationAfterStep', () => {\n    beforeEach(() => {\n      const dateNowStub = jest.fn(() => 1530518207007);\n      global.Date.now = dateNowStub;\n    });\n\n    describe('READ async operations', () => {\n      it('should update state to read show async operation as pending state from initial state', () => {\n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'FETCH_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'READ',\n          },\n        );\n\n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.BEGIN_ASYNC_OPERATION, 'FETCH_PERSON_DATA', { personId: 111 });\n        expect(newOperationsState).to.nested.include({ 'operations.FETCH_PERSON_DATA_111.fetchStatus': 'PENDING' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing begun read async operation');\n      });\n\n      it('should update state to read show async operation as successful state from pending state', () => {\n        state = {\n          operations: {\n            FETCH_PERSON_DATA_111: {\n              descriptorId: 'FETCH_PERSON_DATA',\n              fetchStatus: 'PENDING',\n              dataStatus: 'ABSENT',\n              message: null,\n              lastFetchStatusTime: 0,\n              lastDataStatusTime: 0,\n              personId: 111,\n            },\n          },\n        };\n\n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'FETCH_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'READ',\n          },\n        );\n\n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.RESOLVE_ASYNC_OPERATION, 'FETCH_PERSON_DATA', { personId: 111 });\n\n        expect(newOperationsState).to.nested.include({ 'operations.FETCH_PERSON_DATA_111.fetchStatus': 'SUCCESSFUL' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing successful read async operation');\n      });\n\n      it('should update state to read show async operation as failed state from pending state', () => {\n        state = {\n          operations: {\n            FETCH_PERSON_DATA_111: {\n              descriptorId: 'FETCH_PERSON_DATA',\n              fetchStatus: 'PENDING',\n              dataStatus: 'ABSENT',\n              message: null,\n              lastFetchStatusTime: 0,\n              lastDataStatusTime: 0,\n              personId: 111,\n            },\n          },\n        };\n\n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'FETCH_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'READ',\n          },\n        );\n\n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.REJECT_ASYNC_OPERATION, 'FETCH_PERSON_DATA', { personId: 111 });\n        expect(newOperationsState).to.nested.include({ 'operations.FETCH_PERSON_DATA_111.fetchStatus': 'FAILED' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing rejected async operation');\n      });\n    });\n\n    describe('WRITE async operations', () => {\n      it('should update state to show write async operation as pending state from initial state', () => {\n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'UPDATE_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'WRITE',\n          },\n        );\n  \n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.BEGIN_ASYNC_OPERATION, 'UPDATE_PERSON_DATA', { personId: 111 });\n        expect(newOperationsState).to.nested.include({ 'operations.UPDATE_PERSON_DATA_111.fetchStatus': 'PENDING' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing pending write async operation');\n      });\n  \n      it('should update state to show write async operation as successful state from pending state', () => {\n        state = {\n          operations: {\n            UPDATE_PERSON_DATA_111: {\n              descriptorId: 'UPDATE_PERSON_DATA',\n              fetchStatus: 'PENDING',\n              message: null,\n              lastFetchStatusTime: 0,\n              lastDataStatusTime: 0,\n              personId: 111,\n            },\n          },\n        };\n  \n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'UPDATE_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'WRITE',\n          },\n        );\n  \n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.RESOLVE_ASYNC_OPERATION, 'UPDATE_PERSON_DATA', { personId: 111 });\n        expect(newOperationsState).to.nested.include({ 'operations.UPDATE_PERSON_DATA_111.fetchStatus': 'SUCCESSFUL' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing successful write async operation');\n      });\n\n      it('should update state to show write async operation as failed state from pending state', () => {\n        state = {\n          operations: {\n            UPDATE_PERSON_DATA_111: {\n              descriptorId: 'UPDATE_PERSON_DATA',\n              fetchStatus: 'PENDING',\n              message: null,\n              lastFetchStatusTime: 0,\n              lastDataStatusTime: 0,\n              personId: 111,\n            },\n          },\n        };\n  \n        registerAsyncOperationDescriptors(\n          {\n            descriptorId: 'UPDATE_PERSON_DATA',\n            requiredParams: ['personId'],\n            operationType: 'WRITE',\n          },\n        );\n  \n        const newOperationsState = getStateForOperationAfterStep(state, ASYNC_OPERATION_STEPS.REJECT_ASYNC_OPERATION, 'UPDATE_PERSON_DATA', { personId: 111 });\n        expect(newOperationsState).to.nested.include({ 'operations.UPDATE_PERSON_DATA_111.fetchStatus': 'FAILED' });\n        expect(newOperationsState).to.matchSnapshot('updated state showing failed write async operation');\n      });\n    });\n  });\n});\n"],"file":"asyncOperationManagerUtils_test.js"}